
#include "InOut.h"



InOutfunctions::VecString InOutfunctions::ReadInputfile(std::string dir, std::string fileName)
{
	std::string fullfilepath;
	fullfilepath.append(dir);
	fullfilepath.append("/");
	fullfilepath.append(fileName);

	std::ifstream input_file;
	input_file.open(fullfilepath);
	std::string line;
	std::vector<std::string> data;
	while (std::getline(input_file, line)) {
		data.push_back(line);
	}
	return data;
}


void InOutfunctions::CageCentroidToGRO(std::string filename, InOutfunctions::VecOfVecDouble CageCentroids, VecString CageTypes, std::string BoxDimAngle)
{
	std::ofstream myfile (filename);
	int decimal_places = 2;
	const double multiplier = std::pow(10.0, decimal_places);

	// Get the number of cages
	int numCages = CageCentroids.size();

	if (myfile.is_open()) 
	{
		myfile << "Cage centroids, generated by the c++ code, written by Meisam Adibifard \n";
		myfile << numCages << "\n";

		for (int i = 0; i < CageCentroids.size(); i++)
		{
			double x = std::ceil(CageCentroids[i].x* multiplier)/ multiplier;
			double y = std::ceil(CageCentroids[i].y* multiplier)/ multiplier;
			double z = std::ceil(CageCentroids[i].z* multiplier)/ multiplier;
			
			myfile << "   " << i+1 << "CGE" << "    " << CageTypes[i] << "      " << i+1 << "   " << x << "   " << y << "   " << z << "\n";
		}

		myfile << BoxDimAngle<<"\n";
	}


}


int InOutfunctions::GetNumDigits(int N)
{
	int count = 0;

	int temp = N;

	while (temp != 0) {
		count++;
		// Remove last digit of 'temp'
		temp /= 10;
	}

	return count;
}



void InOutfunctions::CageMoleculesToGRO(std::string filename, std::vector<CageDetectionAlgorithms::Cage> Cage, VecOfVec AllPlanes,  std::vector<HBondedWaters::Molecule> Water, std::string BoxDimAngle, std::vector<HBondedWaters::Molecule>& WatersInCage)
{
	std::ofstream myfile(filename);
	int decimal_places = 2;
	const double multiplier = std::pow(10.0, decimal_places);

	// Get the number of cages
	int numCages = Cage.size();

	if (myfile.is_open())
	{
		myfile << "Cage centroids, generated by the c++ code, written by Meisam Adibifard \n";
		myfile << numCages << "\n";

		int numWaterMol = 0;
		int O_num = 0;
		int H1_num = 0;
		int H2_num = 0;


		for (int i = 0; i < Cage.size(); i++)
		{
			for (int j = 0; j < Cage[i].planes.size(); j++)
			{
				// get the molecules on the plane
				std::vector<int> PlaneMolecules= AllPlanes[Cage[i].planes[j]];
				// Get the list of the water molecules for the plane
				for (int k = 0; k < PlaneMolecules.size(); k++) 
				{
					double xO = std::ceil(Water[PlaneMolecules[k]].ro.x * multiplier) / multiplier;
					double yO = std::ceil(Water[PlaneMolecules[k]].ro.y * multiplier) / multiplier;
					double zO = std::ceil(Water[PlaneMolecules[k]].ro.z * multiplier) / multiplier;

					double xH1 = std::ceil(Water[PlaneMolecules[k]].rh1.x * multiplier) / multiplier;
					double yH1 = std::ceil(Water[PlaneMolecules[k]].rh1.y * multiplier) / multiplier;
					double zH1 = std::ceil(Water[PlaneMolecules[k]].rh1.z * multiplier) / multiplier;

					double xH2 = std::ceil(Water[PlaneMolecules[k]].rh2.x * multiplier) / multiplier;
					double yH2 = std::ceil(Water[PlaneMolecules[k]].rh2.y * multiplier) / multiplier;
					double zH2 = std::ceil(Water[PlaneMolecules[k]].rh2.z * multiplier) / multiplier;

					WatersInCage.push_back(Water[PlaneMolecules[k]]);

					// Update the moleclue number
					numWaterMol += 1;
					O_num =(numWaterMol-1) * 3 + 1;
					H1_num = (numWaterMol - 1) * 3 + 2;
					H2_num = (numWaterMol - 1) * 3 + 3;

					myfile << std::fixed;
					myfile << std::setprecision(2);
					// Write out the coordinates of the water molecules of the cage to the .gro file
					int numWaterMol_digits = GetNumDigits(numWaterMol);
					int O_num_digits = GetNumDigits(O_num);
					int H1_num_digits = GetNumDigits(H1_num);
					int H2_num_digits = GetNumDigits(H2_num);

					//// write-out O coordinates
					for (size_t iWat = 0; iWat < (5- numWaterMol_digits); iWat++)
					{
						myfile << " ";
					}

					myfile << numWaterMol << "SOL" << "    " << "O" ;

					for (size_t iOMol = 0; iOMol < (7 - O_num_digits); iOMol++)
					{
						myfile << " ";
					}
					myfile << O_num << "   " << xO << "   " << yO << "   " << zO << "\n";

					//// write-out H1 coordinates
					for (size_t iWat = 0; iWat < (5 - numWaterMol_digits); iWat++)
					{
						myfile << " ";
					}

					myfile << numWaterMol << "SOL" << "    " << "H";

					for (size_t iHMol = 0; iHMol < (7 - H1_num_digits); iHMol++)
					{
						myfile << " ";
					}

					myfile << H1_num << "   " << xH1 << "   " << yH1 << "   " << zH1 << "\n";


					//// write-out H2 coordinates
					for (size_t iWat = 0; iWat < (5 - numWaterMol_digits); iWat++)
					{
						myfile << " ";
					}
					myfile << numWaterMol << "SOL" << "    " << "H";;

					for (size_t iHMol = 0; iHMol < (7 - H2_num_digits); iHMol++)
					{
						myfile << " ";
					}

					myfile << H2_num << "   " << xH2 << "   " << yH2 << "   " << zH2 << "\n";

				}
			}
			
		}

		myfile << BoxDimAngle << "\n";
	}
}


void InOutfunctions::WaterMoleculesCageLabelled(std::string filename, std::vector<HBondedWaters::Molecule>& WaterMol, std::vector<CageDetectionAlgorithms::Cage> Cages, VecOfVec AllPlanes, std::string BoxDimAngle)
{
	std::ofstream myfile(filename);
	int decimal_places = 2;
	const double multiplier = std::pow(10.0, decimal_places);

	// Get the number of water molecules
	int numWaterMol = WaterMol.size();
	int numAllatoms = numWaterMol * 3; // assuming each water molecule constitutes an oxygen and two hydrogen atoms
	for (auto WaterItr = WaterMol.begin(); WaterItr != WaterMol.end(); ++WaterItr) 
	{
		for (auto CageItr= Cages.begin(); CageItr!= Cages.end(); ++CageItr)
		{
			for (auto PlaneItr = (*CageItr).planes.begin(); PlaneItr != (*CageItr).planes.end(); ++PlaneItr)
			{
				auto a = AllPlanes[*PlaneItr];
				auto WatIndex = std::distance(WaterMol.begin(), WaterItr);
				if (std::find(AllPlanes[*PlaneItr].begin(), AllPlanes[*PlaneItr].end(), WatIndex) != AllPlanes[*PlaneItr].end())
				{
					(*WaterItr).CageLable.push_back((*CageItr).label);
					break; // do not need to check the rest of the planes within the cage
				}
			}
		}
		if ((*WaterItr).CageLable.empty()) 
		{
			(*WaterItr).CageLable.push_back("free");
		}
	}

	if (myfile.is_open()) 
	{
		myfile << "Water Molecules coordinates and cage labels, generated by the C++ code, written by Meisam Adibifard \n";
		myfile << numAllatoms << "\n";

		int numWaterMol = 0;
		int O_num = 0;
		int H1_num = 0;
		int H2_num = 0;

		for (auto WaterItr = WaterMol.begin(); WaterItr != WaterMol.end(); ++WaterItr)
		{
			// Get the coordinates of the H-O-H atoms in the water molecule
			double xO = std::ceil((*WaterItr).ro.x * multiplier) / multiplier;
			double yO = std::ceil((*WaterItr).ro.y * multiplier) / multiplier;
			double zO = std::ceil((*WaterItr).ro.z * multiplier) / multiplier;

			double xH1 = std::ceil((*WaterItr).rh1.x * multiplier) / multiplier;
			double yH1 = std::ceil((*WaterItr).rh1.y * multiplier) / multiplier;
			double zH1 = std::ceil((*WaterItr).rh1.z * multiplier) / multiplier;

			double xH2 = std::ceil((*WaterItr).rh2.x * multiplier) / multiplier;
			double yH2 = std::ceil((*WaterItr).rh2.y * multiplier) / multiplier;
			double zH2 = std::ceil((*WaterItr).rh2.z * multiplier) / multiplier;

			// Update the moleclue number
			numWaterMol += 1;
			O_num = (numWaterMol - 1) * 3 + 1;
			H1_num = (numWaterMol - 1) * 3 + 2;
			H2_num = (numWaterMol - 1) * 3 + 3;

			myfile << std::fixed;
			myfile << std::setprecision(2);

			// Write out the coordinates of the water molecules of the cage to the .gro file
			int numWaterMol_digits = GetNumDigits(numWaterMol);
			int O_num_digits = GetNumDigits(O_num);
			int H1_num_digits = GetNumDigits(H1_num);
			int H2_num_digits = GetNumDigits(H2_num);

			//////////////////////////////////////////////////////////////////////////// write-out O coordinates ///////////////////////////////////////////////////////////////
			for (size_t iWat = 0; iWat < (5 - numWaterMol_digits); iWat++)
			{
				myfile << " ";
			}

			myfile << numWaterMol << "SOL" << "    " << "O";

			for (size_t iOMol = 0; iOMol < (7 - O_num_digits); iOMol++)
			{
				myfile << " ";
			}
			myfile << O_num << "   " << xO << "   " << yO << "   " << zO;

			// Add the cage label
			myfile << "    ";
			for (auto& label : WaterItr->CageLable) 
			{
				myfile << label<<" ";
			}
			myfile << "\n";

			//////////////////////////////////////////////////////////////////////////// write-out H1 coordinates ///////////////////////////////////////////////////////////////
			for (size_t iWat = 0; iWat < (5 - numWaterMol_digits); iWat++)
			{
				myfile << " ";
			}

			myfile << numWaterMol << "SOL" << "    " << "H";

			for (size_t iHMol = 0; iHMol < (7 - H1_num_digits); iHMol++)
			{
				myfile << " ";
			}

			myfile << H1_num << "   " << xH1 << "   " << yH1 << "   " << zH1 << "\n";


			//////////////////////////////////////////////////////////////////////////// write-out H2 coordinates ///////////////////////////////////////////////////////////////
			for (size_t iWat = 0; iWat < (5 - numWaterMol_digits); iWat++)
			{
				myfile << " ";
			}
			myfile << numWaterMol << "SOL" << "    " << "H";;

			for (size_t iHMol = 0; iHMol < (7 - H2_num_digits); iHMol++)
			{
				myfile << " ";
			}

			myfile << H2_num << "   " << xH2 << "   " << yH2 << "   " << zH2 << "\n";
		}
		myfile << BoxDimAngle << "\n";
	}
}



void InOutfunctions::WriteToExcel(std::string filename, std::span<std::vector<CageDetectionAlgorithms::Cage>>  data, std::string colName )
{
	std::fstream fout;

	
	fout.open(filename, std::ios::out | std::ios::app);

	fout << colName << "\n";

	for (auto cagesPertstep : data) 
	{
		fout << cagesPertstep.size() << "\n";
	}

}

std::vector<std::vector<std::string>> InOutfunctions::ExtractDatafromInputStringVector(std::vector<std::string> InputData, std::vector<std::string> MolcIDs)
{
	std::vector<std::vector<std::string>> ExtractedDataTimeVariable;

	unsigned int numAtoms = int(std::stoi(InputData[1])); // this includes h, o, and ch4
	size_t numAtomsToOutput = MolcIDs.size() * 3;

	// Assuming that the number of atoms do not change over time
	unsigned int NlinePerStep = numAtoms + 3;
	unsigned int NtimeSteps;
	if (InputData.size() > NlinePerStep)
	{
		// there are multiple time - steps
		NtimeSteps = int(InputData.size() / NlinePerStep);
	}
	else
	{
		NtimeSteps = 2;
	}

	for (unsigned int i = 0; i < NtimeSteps - 1; ++i)
	{
		unsigned int lbStep = NlinePerStep * i;
		unsigned int upStep = NlinePerStep * (i + 1);

		std::vector<std::string> tmoMolNames;
		for (unsigned int j = lbStep + 2; j < upStep - 2; j++)
		{
			std::vector<std::string> tmpline = lineToListOfStrings(InputData[j]);
			tmoMolNames.push_back(tmpline[0]);
		}

		std::vector<std::string> tmpData;
		for (auto Id = MolcIDs.begin(); Id != MolcIDs.end(); ++Id)
		{
			std::vector<std::string>::iterator it = std::find(tmoMolNames.begin(), tmoMolNames.end(), *Id);
			if (it != tmoMolNames.end())
			{
				std::size_t index = std::distance(std::begin(tmoMolNames), it)+ lbStep +2;
				tmpData.push_back(InputData [index]); tmpData.push_back(InputData[index+1]); tmpData.push_back(InputData[index+2]);
			}
		}
		ExtractedDataTimeVariable.push_back(tmpData);

		tmpData.clear();
	}

	return ExtractedDataTimeVariable;
	
}

void InOutfunctions::CageAssociatedWaterMoleculesTrajectory(std::string Outputfilename,std::vector<std::string> InputData, std::vector<CageDetectionAlgorithms::Cage> Cages,VecOfVec AllPlanes, std::vector<HBondedWaters::Molecule> WaterMols )
{

	// Grab the ids of the cage associated water molecules
	std::vector<std::string> WaterIDsInCage;
	for (auto Cageitr = Cages.begin(); Cageitr != Cages.end(); ++Cageitr) 
	{
		for (auto Planeitr = Cageitr->planes.begin(); Planeitr != Cageitr->planes.end(); ++Planeitr) 
		{
			for (auto Wateritr = AllPlanes[*Planeitr].begin(); Wateritr != AllPlanes[*Planeitr].end(); ++Wateritr) 
			{
				WaterIDsInCage.push_back(WaterMols[*Wateritr].WaterID);
			}			
		}
	}
	// Remove duplicates from the list of the water molecules
	std::sort(WaterIDsInCage.begin(), WaterIDsInCage.end());
	WaterIDsInCage.erase(std::unique(WaterIDsInCage.begin(), WaterIDsInCage.end()), WaterIDsInCage.end());

	std::vector<std::vector<std::string>> ExatractedData = ExtractDatafromInputStringVector(InputData, WaterIDsInCage);

	// Dump the extracted temporal data into a .gro file
	std::string BoxDimAngleStr = InputData[InputData.size()-1];

	std::ofstream myfile(Outputfilename);
	if (myfile.is_open()) 
	{
		for (auto timeStep = ExatractedData.begin(); timeStep != ExatractedData.end(); timeStep++)
		{
			myfile << "Generated by the C++ code written by Meisam Adibifard" << "\n";
			myfile << timeStep->size() << "\n";
			for (auto mol = timeStep->begin(); mol != timeStep->end(); mol++) 
			{
				myfile<<*mol<< "\n";
			}
			myfile << BoxDimAngleStr << "\n";
		}
	}

	
}

std::vector<std::string> InOutfunctions::WriteInStringVector(std::string BoxDimAngle, VecString CageTypes, VecOfVecDouble CageCentroids) 
{
	std::vector<std::string> cagesPerStep;
	// Get the number of cages
	int numCages = CageCentroids.size();
	int decimal_places = 2;
	const double multiplier = std::pow(10.0, decimal_places);

	cagesPerStep.push_back("Cage centroids, generated by the c++ code, written by Meisam Adibifard");

	cagesPerStep.push_back(std::to_string(numCages));

	for (int i = 0; i < CageCentroids.size(); i++)
	{
		double x = std::ceil(CageCentroids[i].x * multiplier) / multiplier;
		double y = std::ceil(CageCentroids[i].y * multiplier) / multiplier;
		double z = std::ceil(CageCentroids[i].z * multiplier) / multiplier;
		std::ostringstream oss;

		oss<< "   " << i + 1 << "CGE" << "    " << CageTypes[i] << "      " << i + 1 << "   " << x << "   " << y << "   " << z ;

		std::string line = oss.str();

		cagesPerStep.push_back(line);
	}

	cagesPerStep.push_back(BoxDimAngle);


	return cagesPerStep;
}

